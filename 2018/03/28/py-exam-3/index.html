<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 【Python学习笔记】几道笔试题（3） · Orangecsy's Blog</title><meta name="description" content="【Python学习笔记】几道笔试题（3） - orangecsy"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://orangecsy.github.io/atom.xml" title="Orangecsy's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/orangecsy" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://blog.csdn.net/orangecsy" target="_blank" class="nav-list-link">CSDN</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">【Python学习笔记】几道笔试题（3）</h1><div class="post-info">2018年3月28日</div><div class="post-content"><p>继续记录最近做的一些笔试题。<br><a id="more"></a></p>
<h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>下列选项中，不可能是快速排序第二趟排序结果的是：<br>A、2，3，5，4，6，7，9<br>B、2，7，5，6，4，3，9<br>C、3，2，5，4，7，6，9<br>D、4，2，3，5，7，6，9<br>尝试：快排的思想是找到一个值（一般选择数组第一个元素），将比这个值小的所有元素放到该值左边，比这个值大的元素放到该值右边，然后分别对左右使用快排并合并，直到切分后的数组长度为1为止。因此我判断数组内排序的大致顺序是：最小，较小，较大，最大。B中7、3位置与这种顺序不符。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fast_sort</span><span class="params">(arr)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:  </span><br><span class="line">        <span class="keyword">return</span> arr  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        middle_value = arr[<span class="number">0</span>]  </span><br><span class="line">        left = []  </span><br><span class="line">        middle = [middle_value]  </span><br><span class="line">        right = []  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:]:  </span><br><span class="line">            <span class="keyword">if</span> i&lt;middle_value:  </span><br><span class="line">                left.append(i)  </span><br><span class="line">            <span class="keyword">elif</span> i&gt;middle_value:  </span><br><span class="line">                right.append(i)  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                middle.append(i)  </span><br><span class="line">        left = fast_sort(left)  </span><br><span class="line">        right = fast_sort(right)  </span><br><span class="line">        <span class="keyword">return</span> left+middle+right</span><br></pre></td></tr></table></figure></p>
<p>修改：当快排中间值正好是待排数组中最小值（或最大值）时，快排退化为冒泡排序，因此经过这一轮排序，仅被选中的值会被排序正确。这种情况就会造成元素分布不会呈低-中-高这样的顺序，而是正确-乱序（或乱序-正确）。<a href="https://blog.csdn.net/u011240016/article/details/53149645" target="_blank" rel="noopener">快排第n趟排序结果校验</a>中给出的解法是：每趟排序就会至少有一个元素排在了最终的位置上，因此只需要比较排序后与正确结果的相同位数。<br>分析：快排利用中间值，将比中间值小（大）的元素排在左（右）边，因此经过这次排序后，中间值的位置一定正确。B的情况是被选为中间值是最小值和最大值，即只有首尾两个元素排序正确。  </p>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>输入包括多组测试数据。每组输入第一行是两个正整数N和M（0 &lt; N &lt;= 30000,0 &lt; M &lt; 5000），分别代表学生的数目和操作的数目。学生ID编号从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来又M行，每一行有一个字符C（只取‘Q’或‘U’），和两个正整数A,B,当C为’Q’的时候, 表示这是一条询问操作，他询问ID从A到B（包括A,B）的学生当中，成绩最高的是多少。当C为‘U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。<br>对于每一次询问操作，在一行里面输出最高成绩。<br>样例输入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span>  </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>  </span><br><span class="line">Q <span class="number">1</span> <span class="number">5</span>  </span><br><span class="line">U <span class="number">3</span> <span class="number">6</span>  </span><br><span class="line">Q <span class="number">3</span> <span class="number">4</span>  </span><br><span class="line">Q <span class="number">4</span> <span class="number">5</span>  </span><br><span class="line">U <span class="number">4</span> <span class="number">5</span>  </span><br><span class="line">U <span class="number">2</span> <span class="number">9</span>  </span><br><span class="line">Q <span class="number">1</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>样例输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>  </span><br><span class="line"><span class="number">6</span>  </span><br><span class="line"><span class="number">5</span>  </span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>尝试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:  </span><br><span class="line">    n, m = list(map(int, sys.stdin.readline().strip().split()))  </span><br><span class="line">    init = list(map(int, sys.stdin.readline().strip().split()))  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):  </span><br><span class="line">        line = sys.stdin.readline().strip().split()  </span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">'Q'</span>:  </span><br><span class="line">            a, b = list(map(int, line[<span class="number">1</span>:]))  </span><br><span class="line">            print(max(init[a<span class="number">-1</span>:b]))  </span><br><span class="line">        <span class="keyword">elif</span> line[<span class="number">0</span>] == <span class="string">'U'</span>:  </span><br><span class="line">            a, b = list(map(int, line[<span class="number">1</span>:]))  </span><br><span class="line">            init[a<span class="number">-1</span>] = b</span><br></pre></td></tr></table></figure></p>
<p>报错，第三行没有足够变量解构赋值。应该是测试样例用完未退出，在外层加上try-except。之后测试用例中有一项“Q 9 5”没有跑通，加if判断ab大小。<br>修改：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:  </span><br><span class="line">        n, m = list(map(int, sys.stdin.readline().strip().split()))  </span><br><span class="line">        init = list(map(int, sys.stdin.readline().strip().split()))  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):  </span><br><span class="line">            line = sys.stdin.readline().strip().split()  </span><br><span class="line">            <span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">'Q'</span>:  </span><br><span class="line">                a, b = list(map(int, line[<span class="number">1</span>:]))  </span><br><span class="line">                <span class="keyword">if</span> a&gt;b:  </span><br><span class="line">                    a, b = b, a  </span><br><span class="line">                print(max(init[a<span class="number">-1</span>:b]))  </span><br><span class="line">            <span class="keyword">elif</span> line[<span class="number">0</span>] == <span class="string">'U'</span>:  </span><br><span class="line">                a, b = list(map(int, line[<span class="number">1</span>:]))  </span><br><span class="line">                init[a<span class="number">-1</span>] = b  </span><br><span class="line"><span class="keyword">except</span>:  </span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。<br>1.记录最多8条错误记录，对相同的错误记录(即文件名称和行号完全匹配)只记录一条，错误计数增加；(文件所在的目录不同，文件名和行号相同也要合并)<br>2.超过16个字符的文件名称，只记录文件的最后有效16个字符；(如果文件名不同，而只是文件名的后16个字符和行号相同，也不要合并)<br>3.输入的文件可能带路径，记录文件名称不能带路径。<br>输入：<br>一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。<br>文件路径为windows格式如：E:\V1R2\product\fpgadrive.c 1325<br>输出：<br>将所有的记录统计并将结果输出，格式：文件名代码行数数目，一个空格隔开，如: fpgadrive.c 1325 1<br>结果根据数目从多到少排序，数目相同的情况下，按照输入第一次出现顺序排序。<br>如果超过8条记录，则只输出前8条记录。如果文件名的长度超过16个字符，则只输出后16个字符<br>尝试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    dic = &#123;&#125;  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:  </span><br><span class="line">            line = sys.stdin.readline().strip().split()  </span><br><span class="line">            <span class="keyword">if</span> len(line) == <span class="number">0</span>:  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">            pos = line[<span class="number">0</span>].rfind(<span class="string">'\\'</span>)  </span><br><span class="line">            line = line[<span class="number">0</span>][pos+<span class="number">1</span>:]+<span class="string">' '</span>+line[<span class="number">1</span>]  </span><br><span class="line">            <span class="keyword">if</span> line <span class="keyword">in</span> dic:  </span><br><span class="line">                dic[line] = dic[line]+<span class="number">1</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                dic[line] = <span class="number">1</span>  </span><br><span class="line">        res_value = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>)]  </span><br><span class="line">        res_key = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>)]  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dic:  </span><br><span class="line">            <span class="keyword">if</span> dic[i]&lt;=res_value[<span class="number">-1</span>]:  </span><br><span class="line">                <span class="keyword">continue</span>  </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">8</span>):  </span><br><span class="line">                <span class="keyword">if</span> dic[i]&gt;res_value[j]:  </span><br><span class="line">                    res_value.insert(j, dic[i])  </span><br><span class="line">                    res = i.split()[<span class="number">0</span>][<span class="number">-16</span>:]+<span class="string">' '</span>+i.split()[<span class="number">1</span>]+<span class="string">' '</span>+str(dic[i])  </span><br><span class="line">                    res_key.insert(j, res)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">        resPrint = <span class="string">' '</span>  </span><br><span class="line">        resPrint = resPrint.join(res_key[:<span class="number">8</span>])  </span><br><span class="line">        print(resPrint)  </span><br><span class="line">    <span class="keyword">except</span>:  </span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>思路：读取完整文件名称（输出时再截取16位）和行号，作为key，值为出现次数，存入字典中。读取完毕后，遍历字典，res_value中存放前8位最大值。当字典中的值大于列表中j位置的值时，将字典的value插入res_value中，key插入res_key中。当有相同大小的value时，从前向后遍历且判断是否大于可将后放入的key存在后面，满足题意。提交，未能AC。<br>问题分析：<br>1、python中字典类型是无序的，不会记录放入顺序。当遍历字典时，不会以添加的先后顺序遍历，而是以key字典序遍历，因此需改用列表记录顺序。<br>2、当输入文件数较小时，res_key中还存在初始填充的0值，因此需要判断前8位中是否还有0元素。<br>3、输出格式不符合规范。经过测试，本题需要每个错误项作为一行，而不是拼接为一个字符串。<br>修改：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    dic = []  </span><br><span class="line">    dic_value = []  </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:  </span><br><span class="line">            line = sys.stdin.readline().strip().split()  </span><br><span class="line">            <span class="keyword">if</span> len(line) == <span class="number">0</span>:  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">            pos = line[<span class="number">0</span>].rfind(<span class="string">'\\'</span>)  </span><br><span class="line">            line = line[<span class="number">0</span>][pos+<span class="number">1</span>:]+<span class="string">' '</span>+line[<span class="number">1</span>]  </span><br><span class="line">            <span class="keyword">if</span> line <span class="keyword">in</span> dic:  </span><br><span class="line">                dic_value[dic.index(line)] = dic_value[dic.index(line)]+<span class="number">1</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                dic.append(line)  </span><br><span class="line">                dic_value.append(<span class="number">1</span>)  </span><br><span class="line">    res_value = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>)]  </span><br><span class="line">    res_key = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>)]  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dic)):  </span><br><span class="line">        <span class="keyword">if</span> dic_value[i]&lt;=res_value[<span class="number">-1</span>]:  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">8</span>):  </span><br><span class="line">            <span class="keyword">if</span> dic_value[i]&gt;res_value[j]:  </span><br><span class="line">                res_value.insert(j, dic_value[i])  </span><br><span class="line">                res = dic[i].split()[<span class="number">0</span>][<span class="number">-16</span>:]+<span class="string">' '</span>+dic[i].split()[<span class="number">1</span>]+<span class="string">' '</span>+str(dic_value[i])  </span><br><span class="line">                res_key.insert(j, res)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">if</span> res_key.index(<span class="number">0</span>)&lt;<span class="number">8</span>:  </span><br><span class="line">        res_key_index = res_key.index(<span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        res_key_index = <span class="number">8</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(res_key_index):  </span><br><span class="line">        print(res_key[i])</span><br></pre></td></tr></table></figure></p>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><p>现在有两堆石子,小今与小条玩游戏,2个人都足够聪明,两个人规定:每次每人只能从其中一堆中取走1个或2个或3个石子,最后将石子全部取完的人胜利.现在两堆石子的个数为8和9,请问如何安排才能让小今必胜?<br>思路：回溯法。为使小今赢得比赛，最后一种情况是小今取完还剩4块石头，小条无论怎么取下一步小今都会赢。因此需将石头控制在4的倍数，即小今第一步走取9块石头中的一个，之后只要控制石头数是4的倍数即可。  </p>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><p>所有新闻真实率到达了98%,工作人员在检验一个真实的新闻把它检验为一个虚假的新闻的概率为2%,而一个虚假的新闻被检验为真实的新闻的概率为5%.那么,一个被检验为真实的新闻确实是真实的新闻的概率是多大?<br>思路：被检验为真实的新闻包括两部分：真实新闻被检验为真实，虚假新闻被检验为真实。其中第一部分占比0.98<em>0.98约为0.96，第二部分占比0.02</em>0.95约为0.001，即被检测为真实的确实为真实新闻的概率为0.96/0.961约为0.99896。  </p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/03/30/js-learn-1/" class="prev">上一篇</a><a href="/2018/03/27/py-exam-2/" class="next">下一篇</a></div><div class="copyright"><p>© 2018 - 2020 <a href="https://orangecsy.github.io">orangecsy</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>